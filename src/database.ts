import { Pool, type PoolClient, DatabaseError } from 'pg'
import SQL from 'sql-template-strings'
import argon2 from 'argon2'
import Logging from './library/Logging'
import {
  type Transaction,
  TransactionSchema,
  type User,
  FailedTransaction
} from './helper/schemas'
import { type BigNumberish, ethers } from 'ethers'
import 'dotenv/config'

// Create a new pool instance
const pool = new Pool({
  host: process.env.PGHOST ?? 'localhost',
  port: 5432,
  user: process.env.PGUSER ?? 'postgres',
  password: process.env.PGPASSWORD ?? 'password',
  database: 'suhel'
})

// Function to connect to the database with retries
// Had to take this approach because when the container starts, the database takes a bit longer to start
// than the application, so the connection fails
const getClient = async (): Promise<PoolClient> => {
  Logging.info('Attempting to connect to the database...')
  try {
    const client = await pool.connect()
    Logging.info('Connected to the database')
    return client
  } catch (e) {
    Logging.error(e)
    Logging.warn('Retrying to connect to the database...')
    // wait for 3 seconds before retrying
    await new Promise((resolve) => setTimeout(resolve, 3000))
    return await getClient()
  }
}

// Log any errors that occur on the idle client
pool.on('error', (err) => {
  if (err instanceof DatabaseError) {
    Logging.error(
      `Unexpected error on idle client: ${err.message}, ${err.name}, ${err.stack}`
    )
  } else {
    Logging.error(err)
  }
})

// Function to create table
export const createTable = async (): Promise<void> => {
  const client = await getClient()
  try {
    // Begin a transaction
    await client.query('BEGIN')

    // Create the table if it doesn't exist
    /**
     * The transactions table will store the following data:
     * - id: A unique identifier for the transaction
     * - sender: The address of the sender
     * - usdc_received: The amount of USDC received
     * - arb_amount: The amount of ARB sent
     * - arb_price: The price of ARB at the time of the transaction
     * - fee: The fee collected
     * - incoming_transaction_hash: The hash of the incoming transaction
     * - outgoing_transaction_hash: The hash of the outgoing transaction
     * - timestamp: The timestamp of the transaction
     */
    const transactionTableCreationQuery = SQL`
      CREATE TABLE IF NOT EXISTS transactions (
        id SERIAL PRIMARY KEY,
        sender VARCHAR(42) NOT NULL,
        usdc_received NUMERIC NOT NULL,
        arb_amount NUMERIC NOT NULL,
        arb_price DECIMAL NOT NULL,
        fee NUMERIC NOT NULL,
        block_number NUMERIC NOT NULL,
        incoming_transaction_hash VARCHAR(66) NOT NULL UNIQUE,
        outgoing_transaction_hash VARCHAR(66) NOT NULL UNIQUE,
        timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        )
    `

    // Create the users table if it doesn't exist
    /**
     * The users table will store the following data:
     * - id: A unique identifier for the user (this will be a UUID generated by the database)
     * - username: The username of the user
     * - password: The password of the user
     * - timestamp: The timestamp of the user creation
     */
    const userTableCreationQuery = SQL`
      CREATE TABLE IF NOT EXISTS users (
        id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
        username VARCHAR(255) NOT NULL UNIQUE,
        password VARCHAR(255) NOT NULL,
        timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        )
    `

    // Create the failed_transactions table if it doesn't exist
    // All transactions that fail to process due to any reason, like:
    // - RPC Call failure
    // - Transaction Revert
    // - Coingecko API failure
    // Will be stored in this table
    /**
     * The failed transactions table will store the following data:
     * - id: A unique identifier for the failed txn
     * - log: The log of the failed transaction that needs to be retried
     * - error: The error message of the failed transaction
     * - timestamp: The timestamp of the user creation
     */
    const failedTransactionTableCreationQuery = SQL`
      CREATE TABLE IF NOT EXISTS failed_transactions (
        id SERIAL PRIMARY KEY,
        log TEXT NOT NULL,
        error TEXT NOT NULL,
        timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        )
    `
    await client.query(transactionTableCreationQuery)
    await client.query(userTableCreationQuery)
    await client.query(failedTransactionTableCreationQuery)
    // Commit the transaction
    await client.query('COMMIT')
  } catch (e) {
    // Rollback the transaction if an error occurs
    await client.query('ROLLBACK')
    throw e
  } finally {
    // Release the client back to the pool
    client.release()
  }
}

// Function to insert data into the table
export const insertTransaction = async ({
  sender,
  usdcReceived,
  arbAmount,
  arbPrice,
  fee,
  blockNumber,
  incomingTransactionHash,
  outgoingTransactionHash
}: Transaction): Promise<void> => {
  // Validate the input data using zod
  const valid = TransactionSchema.safeParse({
    sender,
    usdcReceived,
    arbAmount,
    arbPrice,
    fee,
    blockNumber,
    incomingTransactionHash,
    outgoingTransactionHash
  })
  // If the data is invalid, throw an error
  if (!valid.success) {
    throw new Error(valid.error.errors[0].message)
  }
  const client = await pool.connect()
  try {
    await client.query('BEGIN')
    const query = SQL`
      INSERT INTO transactions (sender, usdc_received, arb_amount, arb_price, fee, block_number, incoming_transaction_hash, outgoing_transaction_hash)
      VALUES (${sender.toLowerCase()}, ${usdcReceived}, ${arbAmount}, ${arbPrice}, ${fee}, ${blockNumber}, ${incomingTransactionHash.toLowerCase()}, ${outgoingTransactionHash.toLowerCase()})
    `
    await client.query(query)
    await client.query('COMMIT')
  } catch (e) {
    await client.query('ROLLBACK')
    throw e
  } finally {
    client.release()
  }
}

// Function to insert new user into the table
export const insertUser = async ({
  username,
  password: _password
}: User): Promise<void> => {
  const client = await pool.connect()
  try {
    await client.query('BEGIN')
    // Hash the password using argon2
    const password = await argon2.hash(_password)
    const query = SQL`
      INSERT INTO users (username, password)
      VALUES (${username}, ${password})
    `
    await client.query(query)
    await client.query('COMMIT')
  } catch (e) {
    await client.query('ROLLBACK')
    throw e
  } finally {
    client.release()
  }
}

// Function to insert failed transaction into the table
export const insertFailedTransaction = async (
  log: string,
  error: string
): Promise<void> => {
  const client = await pool.connect()
  try {
    await client.query('BEGIN')
    const query = SQL`
      INSERT INTO failed_transactions (log, error)
      VALUES (${log}, ${error})
  `
    await client.query(query)
    await client.query('COMMIT')
  } catch (e) {
    await client.query('ROLLBACK')
    throw e
  } finally {
    client.release()
  }
}

// Function to fetch user from the table
export const fetchUser = async (
  username: string,
  _password: string
): Promise<boolean | { id: string; valid: boolean }> => {
  const client = await pool.connect()
  try {
    // Fetch the user from the database
    const query = SQL`
      SELECT * FROM users
      WHERE username = ${username}
    `
    const result = await client.query(query)
    // If the user doesn't exist, return false
    if (result.rows.length === 0) {
      return false
    }
    const password = result.rows[0].password
    // Verify the password using argon2
    const isPasswordCorrect = await argon2.verify(password as string, _password)
    // Return the user id and whether the password is correct
    return {
      id: result.rows[0].id,
      valid: isPasswordCorrect
    }
  } finally {
    client.release()
  }
}

// Function to fetch the latest block number from the table
export const fetchLatestBlockNumber = async (): Promise<number> => {
  const client = await pool.connect()
  try {
    // this query would sort the transactions by block number in descending order and return the block number of the first row
    const query = SQL`
      SELECT block_number FROM transactions
      ORDER BY block_number DESC
      LIMIT 1
    `
    const result = await client.query(query)
    // If there are no transactions, return 0
    if (result.rows.length === 0) {
      return 0
    }
    return result.rows[0].block_number
  } finally {
    client.release()
  }
}

// Function to fetch all failed transactions from the table
export const fetchFailedTransactions = async (): Promise<
  FailedTransaction[]
> => {
  const client = await pool.connect()
  try {
    const query = SQL`
      SELECT * FROM failed_transactions
    `
    const result = await client.query(query)
    return result.rows
  } finally {
    client.release()
  }
}

// Function to delete all failed transactions from the table
export const deleteFailedTransaction = async (): Promise<void> => {
  const client = await pool.connect()
  try {
    const query = SQL`
      DELETE FROM failed_transactions
    `
    await client.query(query)
  } finally {
    client.release()
  }
}

// Function to return all the transactions from the table
export const fetchTransactions = async (): Promise<Transaction[]> => {
  const client = await pool.connect()
  try {
    const query = SQL`
      SELECT * FROM transactions
    `
    const result = await client.query(query)
    return result.rows
  } finally {
    client.release()
  }
}

// Function to return the top 5 transactions by USDC received
export const fetchTop5Transactions = async (): Promise<Transaction[]> => {
  const client = await pool.connect()
  try {
    // arrange the transactions in descending order of USDC received and return the top 5
    const query = SQL`
      SELECT * FROM transactions
      ORDER BY usdc_received DESC
      LIMIT 5
    `
    const result = await client.query(query)
    return result.rows
  } finally {
    client.release()
  }
}

// Function to return the top 5 transactions by sender
export const fetchTop5TransactionsBySender = async (
  sender: string
): Promise<Transaction[]> => {
  const client = await pool.connect()
  try {
    // arrange the transactions of a particular user in descending order of USDC received and return the top 5
    const query = SQL`
      SELECT * FROM transactions
      WHERE sender = ${sender.toLowerCase()}
      ORDER BY usdc_received DESC
      LIMIT 5
    `
    const result = await client.query(query)
    return result.rows
  } finally {
    client.release()
  }
}

// Function to return the lowest USDC received transactions
export const fetchLowestUsdcTransactions = async (): Promise<Transaction[]> => {
  const client = await pool.connect()
  try {
    // first find the minimum USDC received and then return the transactions with that USDC received
    const query = SQL`
      SELECT * FROM transactions
      WHERE usdc_received = (SELECT MIN(usdc_received) FROM transactions)
    `
    const result = await client.query(query)
    return result.rows
  } finally {
    client.release()
  }
}

// Function to return the highest ARB token price
export const fetchHighestArbTokenPrice = async (): Promise<Transaction[]> => {
  const client = await pool.connect()
  try {
    // return the highest ARB token price
    const query = SQL`
      SELECT MAX(arb_price) as highest_price FROM transactions
    `
    const result = await client.query(query)
    return result.rows[0].highest_price
  } finally {
    client.release()
  }
}

// fetch transactions by sender
export const fetchTransactionsBySender = async (
  sender: string
): Promise<Transaction[]> => {
  const client = await pool.connect()
  try {
    // return all the transactions of a particular user
    const query = SQL`
      SELECT * FROM transactions
      WHERE sender = ${sender.toLowerCase()}
    `
    const result = await client.query(query)
    return result.rows
  } finally {
    client.release()
  }
}

// fetch transaction by outgoing hash
export const fetchTransactionByOutgoingHash = async (
  outgoingHash: string
): Promise<Transaction[]> => {
  const client = await pool.connect()
  try {
    const query = SQL`
      SELECT * FROM transactions
      WHERE outgoing_transaction_hash = ${outgoingHash.toLowerCase()}
    `
    const result = await client.query(query)
    return result.rows
  } finally {
    client.release()
  }
}

// fetch transaction by incoming hash
export const fetchTransactionByIncomingHash = async (
  incomingHash: string
): Promise<Transaction[]> => {
  const client = await pool.connect()
  try {
    const query = SQL`
      SELECT * FROM transactions
      WHERE incoming_transaction_hash = ${incomingHash.toLowerCase()}
    `
    const result = await client.query(query)
    return result.rows
  } finally {
    client.release()
  }
}

// fetch transactions by USDC threshold, i.e. return all the transactions with USDC received greater than a certain threshold
export const fetchTransactionsByUsdcThreshold = async (
  threshold: number
): Promise<Transaction[]> => {
  const client = await pool.connect()
  try {
    const query = SQL`
      SELECT * FROM transactions
      WHERE usdc_received > ${threshold}
    `
    const result = await client.query(query)
    return result.rows
  } finally {
    client.release()
  }
}

// fetch transactions by date range i.e. return all the transactions between a certain date range
export const fetchTransactionsByDateRange = async (
  startDate: Date,
  endDate: Date
): Promise<Transaction[]> => {
  const client = await pool.connect()
  try {
    const query = SQL`
      SELECT * FROM transactions
      WHERE timestamp >= ${startDate.toISOString()} AND timestamp <= ${endDate.toISOString()}
    `
    const result = await client.query(query)
    return result.rows
  } finally {
    client.release()
  }
}

// fetch total amount of USDC sent and ARB received by a particular sender
export const fetchTotalUsdcAndArbBySender = async (
  sender: string
): Promise<
  Array<{
    sender: string
    total_usdc_received: number
    total_arb_sent: number
  }>
> => {
  const client = await pool.connect()
  try {
    // first filter the transactions by sender and then return the total USDC received and ARB sent
    const query = SQL`
      SELECT
          sender,
          SUM(usdc_received) AS total_usdc_received,
          SUM(arb_amount) AS total_arb_sent
      FROM
          transactions
      WHERE
          sender = ${sender.toLowerCase()}
      GROUP BY
          sender;
    `
    const result = await client.query(query)
    return result.rows
  } finally {
    client.release()
  }
}

// fetch total transactions count
export const fetchTotalTransactionsCount = async (): Promise<number> => {
  const client = await pool.connect()
  try {
    const query = SQL`
      SELECT COUNT(*) FROM transactions;
    `
    const result = await client.query(query)
    return parseInt(result.rows[0].count as string, 10)
  } finally {
    client.release()
  }
}

// fetch total transactions count by user
export const fetchTotalTransactionsCountByUser = async (
  sender: string
): Promise<number> => {
  const client = await pool.connect()
  try {
    const query = SQL`
      SELECT COUNT(*) FROM transactions WHERE sender = ${sender.toLowerCase()};
    `
    const result = await client.query(query)
    return parseInt(result.rows[0].count as string, 10)
  } finally {
    client.release()
  }
}

// fetch total fee collected in USDC
export const fetchTotalFeeCollected = async (): Promise<string> => {
  const client = await pool.connect()
  try {
    const query = SQL`
      SELECT SUM(fee) AS total_fee_collected FROM transactions;
    `
    const result = await client.query(query)
    return ethers.formatUnits(
      (result.rows[0].total_fee_collected as BigNumberish) ?? 0,
      6
    )
  } finally {
    client.release()
  }
}

// fetch total fee collected by user
export const fetchTotalFeeCollectedByUser = async (
  sender: string
): Promise<string> => {
  const client = await pool.connect()
  try {
    const query = SQL`
      SELECT SUM(fee) AS total_fee_collected FROM transactions
      WHERE sender = ${sender.toLowerCase()};
    `
    const result = await client.query(query)
    return (
      ethers.formatUnits(
        (result.rows[0].total_fee_collected as BigNumberish) ?? 0,
        6
      ) ?? '0'
    )
  } finally {
    client.release()
  }
}

// fetch total fee collected on a particular date
export const fetchTotalFeeCollectedOnDate = async (
  date: Date
): Promise<string> => {
  const client = await pool.connect()
  try {
    const query = SQL`
      SELECT SUM(fee) AS total_fee_collected FROM transactions
      WHERE DATE(timestamp) = DATE(${date});
    `
    const result = await client.query(query)
    return ethers.formatUnits(
      (result.rows[0].total_fee_collected as BigNumberish) ?? 0,
      6
    )
  } finally {
    client.release()
  }
}

// fetch total fee collected from a particular user on a particular date
export const fetchTotalFeeCollectedByUserOnDate = async (
  sender: string,
  date: Date
): Promise<string> => {
  const client = await pool.connect()
  try {
    const query = SQL`
      SELECT SUM(fee) AS total_fee_collected FROM transactions
      WHERE sender = ${sender.toLowerCase()} AND DATE(timestamp) = DATE(${date});
    `
    const result = await client.query(query)
    return ethers.formatUnits(
      (result.rows[0].total_fee_collected as BigNumberish) ?? 0,
      6
    )
  } finally {
    client.release()
  }
}

// fetch average ARB price in USD
export const fetchAverageArbPrice = async (): Promise<number> => {
  const client = await pool.connect()
  try {
    const query = SQL`
      SELECT AVG(arb_price) AS average_arb_price
      FROM transactions;
    `
    const result = await client.query(query)
    return result.rows[0].average_arb_price
  } finally {
    client.release()
  }
}

// fetch average fee collected
export const fetchAverageFeeCollected = async (): Promise<string> => {
  const client = await pool.connect()
  try {
    const query = SQL`
      SELECT AVG(fee) AS average_fee_collected
      FROM transactions;
    `
    const result = await client.query(query)
    return ethers.formatUnits(
      parseInt(result.rows[0].average_fee_collected as string) ?? 0,
      6
    )
  } finally {
    client.release()
  }
}

export const fetchTopSendersByTotalUsdcReceived = async (
  limit: number
): Promise<Array<{ sender: string; total_usdc_received: number }>> => {
  const client = await pool.connect()
  try {
    const query = SQL`
      SELECT sender, SUM(usdc_received) AS total_usdc_received
      FROM transactions
      GROUP BY sender
      ORDER BY total_usdc_received DESC
      LIMIT ${limit};
    `
    const result = await client.query(query)
    return result.rows
  } finally {
    client.release()
  }
}
